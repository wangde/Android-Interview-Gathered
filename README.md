
# Android相关
---
## 事件传递流程
## Android OOM 处理
## 进程保活 ([参考这里](https://segmentfault.com/a/1190000006251859))
* 提供进程优先级，降低进程被杀死的概率
  * 利用 Activity 提升权限
  * 利用 Notification 提升权限(startForeground)
* 在进程被杀死后，进行拉活
  * 利用系统广播拉活
  * 利用第三方应用广播拉活
  * 利用系统Service机制拉活(onStartCommand()中返回Service.START_STICKY)
  * 利用Native进程拉活(利用 Linux 中的 fork 机制创建 Native 进程，在 Native 进程中监控主进程的存活，当主进程挂掉后，在 Native 进程中立即对主进程进行拉活)
  * 利用账号同步机制拉活
  
## 布局的适配
## 四种启动模式
## 性能的优化
## Android 屏幕适配
### *两个重要单位：*
* 密度无关像素(density-independent pixel, dp or dip):与终端上的实际物理像素点无关,可以保证在不同屏幕像素密度的设备上显示相同的效果。Android开发时用dp而不是px单位设置图片大小，是Android特有的单位。
* 独立比例像素(scale-independent pixel, sp or sip):Android开发时用此单位设置文字大小，可根据字体大小首选项进行缩放。
### *屏幕适配要解决的问题：*
* 使得“布局”、“控件”匹配不同的屏幕尺寸
* 使得“图片资源”匹配不同的屏幕密度
一个图片归纳解决办法,转自[这里](http://www.jianshu.com/p/ec5a1a30694b)：
![归纳解决办法](http://upload-images.jianshu.io/upload_images/944365-ced9745859537daf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## Handler机制
Handler，Looper，MessageQueue，Message，Messenger

app启动流程 www.jianshu.com/p/a5532ecc8377
---
# Java相关
---

## 1. Java并发，线程相关
### *什么是线程：*
* 线程是一种轻量级进程，大多数情况下用于执行异步操作。
* 在一个Android 程序开始运行的时候，会单独启动一个进程，同时会产生一个UIThread线程（main线程）。
* 一个Android 程序默认情况下也只有一个进程，但一个进程下却可以有许多个线程。
* 默认的情况下，Service和Activity（还有Content Provider和Broadcast Receiver）会同时运行在进程的main线程中，是会相互阻塞的。
### *线程和进程的区别：*
* 地址空间:进程有自己独立的地址空间.进程至少有一个线程,进程内的所有线程共享进程的地址空间;
* 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源;
* 线程是处理器调度的基本单位,但进程不是.
* 线程只需要很少的资源就可“轻装上阵”运行的优点，来弥补进程并发的“颗粒度”粗糙的缺点，提高系统资源利用率。
### *volatile和Synchronized区别:*
* **volatile:**  它所修饰的变量不保留拷贝，直接访问主内存中的(保证可见性)。
* **synchronized:** 保证在同一时刻最多只有一个线程执行该段代码(保证原子性)。
### *原子性与可见性:*([参考这里](https://my.oschina.net/wangnian/blog/668490))
* **原子性：** 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
* **可见性:** 是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
### *Callable 和 Runnable 的区别:*
* Runnable的run()没有返回值,Callable的call()有返回值,这个返回值具体是通过实现Future接口的对象的get方法获取的，这个方法是会造成线程阻塞的.
* Callable里面的call方法是可以抛出异常的，我们可以捕获异常进行处理
### *线程池的概念、好处、常见的线程池举例:*
* 线程池的好处：
  1. 重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。
  2. 有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞线程。
  3. 能对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。

Android中线程池源自Java的Executor接口。真正的线程池实现为ThreadPoolExecutor。
ThreadPoolExecutor它的构造方法提供了一系列参数来配置线程池。
corePoolSize：线程池核心线程数量
maximumPoolSize：线程池所能容纳的最大线程。
keepAliveTime：非核心线程的闲置超长时间，超过这个时间，非核心线程就会被回收。
unit：用于指定keepAliveTime参数的时间单位。
workQueue：线程池中的任务队列
threadFactory：线程工厂，为线程池提供创建新线程的功能。

* 线程池的分类
  1. **FixedThreadPool**
Executors.newFixedThreadPool方法创建。他是一种固定线程数量的线程池，只有核心线程。这些线程不会被回收。除非线程池被关闭。
  2. **CachedThreadPool**
Executors.newCachedThreadPool方法创建,它一种线程数量不固定的线程池。它只有非核心线程。并且它的线程都有超时机制，超过60秒闲置线程就会被回收。
  3. **ScheduledThreadPool**
Executors.newScheduledThreadPool方法创建，它的核心数量是固定的，而非核心数量没有限制。当非核心线程闲置是会立刻回收。
  4. **SingleThreadExecutor**
Executors.newSingleThreadExecutor方法创建，它只要一个核心线程，能确保所有任务都在一个线程中按顺序执行。它的意义在于统一所有的外界任务到一个线程中。是这些线程任务之间不需要处理线程同步的问题。

## 2. JVM内存空间分区（[参考这里](http://blog.csdn.net/a910626/article/details/52318590)）
- **程序计数器(Program Counter Register):** 程序计数器是当前线程所执行字节码的行号指示器
- **JVM栈(VM Stack):** JVM栈用于存放正在执行的方法，每有一个函数被调用，就会创建一个栈帧压入JVM栈，方法执行完成后，将其栈帧从JVM栈中弹出。所谓的栈帧，就是存放当前方法中的存储局部变量、操作数栈、动态链接、方法出口等信息的一个东西。
- **本地方法栈(Native Method Stack):** 本地方法栈与虚拟机栈所发挥的作用是类似的，其区别不过是本地方法栈则是为虚拟机使用到的native方法服务。
- **堆(Heap):** java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例，几乎所有的对象实例都在这里分配内存。
- **方法区(Method Area):** 是各个线程共享的内存区域，它用于存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

## 3. GC算法（[参考这里](http://www.cnblogs.com/smyhvae/p/4744233.html)）
内存回收针对的是内存空间分区中的 **堆** 和 **方法区** 。
内存区域中的 **程序计数器、虚拟机栈、本地方法栈** 这3个区域随着线程而生，线程而灭，方法结束或者线程结束时，内存自然就跟着回收了，因此在这几个区域不需要过多考虑回收的问题。

* **引用计数算法：** 老牌垃圾回收算法。无法处理循环引用，没有被Java采纳.
* **根搜索算法:**  在根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，分别是标记-清除算法、复制算法、标记-整理算法。这三种算法都扩充了根搜索算法.
* **标记-清除算法：**  通过根节点，标记所有从根节点开始的可达对象。在清除阶段，清除所有未被标记的对象。(缺点：1 效率比较低 2 清理出来的空闲内存不连续)
* **复制算法：** 从根节点，将可达对象复制到新的内存空间中，然后清除原来的内存空间。（清理后的空间是连续的，但是此方法需要较大的内存空间）
* **标记-压缩算法：** 标记步骤同标记-清除法，压缩是指移动所有存活的对象，且按照内存地址次序依次排列。最后将排列后末端内存地址以后的内存全部回收。（效率也不高）
## 4.  Java中的强引用、软引用、弱引用和虚引用
* **目的：** 对象的生命周期，以及利于 JVM 的垃圾回收
* **强引用：** 如果一个对象具有强引用，它就不会被垃圾回收器回收。
---
# 网络相关
---

## TCP、UDP的区别
TCP是面向连接的，可靠的，传输大量数据，速度慢。UDP相反。
## TCP的三次握手、四次挥手
* 三次握手： 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
* 四次挥手：TCP是全双工模式，这就意味着，
  * 当主机1发出FIN报文段时，告诉主机2，它的数据已经全部发送完毕了,但是，这个时候主机1还是可以接受来自主机2的数据；
  * 当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；
  * 当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了;
  * 当主机1返回ACK报文段之后彼此就会愉快的中断这次TCP连接。
## HTTP的特点
* 支持客户/服务器模式。
* 简单快速：客户向服务器请求服务时，只需传送请求方法(GET、HEAD、POST)和路径。
由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
* 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
* 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
* 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。
## HTTP与HTTPS的区别

---
# 算法相关（[参考这里](https://getpocket.com/a/read/982518844)）
---
* **二位数组查找：** 对数组进行排序，没一行从左到右递增，每一列从上往下递增。然后从右上角开始，比较与target的大小，如果等于，结束查找；如果大于target，则删除此列，如果小于target，删除此行；然后从剩下的数组右上角开始查找。
* **替换字符串中空格（替换数组中的元素x）：** 先遍历一遍，统计字符串A中空格个数，然后计算替换后的总长度，生成新的长度的空字符串B。一个指针指向B的结尾，一个指向A的结尾，从后往前遍历A，遇到空格就在B中插入要替换的字符。
* **从尾到头打印链表（栈的使用）：** 利用栈的先进先出原则
* **二进制中1的个数：** 如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。
* **数值的整数次方：** a^n=a^(n/2)*a^(n/2)，(n为偶数)；或者 a^n = a^ ((n-1)/2)*a^((n-1)/2)*a，(n为奇数)
